plot(K)
#Cuadrantes
Q <- pixelquad(X = puntos.ppp, W = as.owin(w))
source("Funciones-spatstat/plotQuantIntens.R") #La función
plotQuantIntens(imList = r.im, # Lista de imágenes
noCuts = 5, # No. de cortes
Quad = Q, # Los cuadrantes
p.pp = puntos.ppp, # El proceso de puntos
dir = "", # Directorio donde se guardará
name = "Respuestas") # Nombre del archivo
library(raster); library(rgdal); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos/", "tif",
full.names = T,
recursive = F)
r <- stack(archivos)
#Definiendo un centroide para simular
centroide <- cellStats(r, mean)
r.df <- data.frame(rasterToPoints(r))
covar <- cov(r.df[, 3:5])
md <- mahalanobis(r.df[, 3:5], center = centroide, cov = covar)
md.r <- rasterFromXYZ(data.frame(r.df[, 1:2], md))
md.exp <- exp(-0.5*md.r)
plot(md.exp)
set.seed(182)
puntos.2 <- dismo::randomPoints(mask = md.exp,
n = 200,
prob = T)
puntos.2 <- data.frame(puntos.2)
puntos.2$x <- puntos.2$x + rnorm(200, 0, 0.05)
puntos.2$y <- puntos.2$y + rnorm(200, 0, 0.05)
plot(md.exp); points(puntos.2)
centroide
set.seed(182)
puntos.2 <- dismo::randomPoints(mask = md.exp,
n = 200,
prob = T)
puntos.2 <- data.frame(puntos.2)
puntos.2$x <- puntos.2$x + rnorm(200, 0, 0.05)
puntos.2$y <- puntos.2$y + rnorm(200, 0, 0.05)
plot(md.exp); points(puntos.2)
source("Funciones-spatstat/imFromStack.R")
source("Funciones-spatstat/winFromRaster.R")
source("Funciones-spatstat/plotQuantIntens.R")
#formateo-Creando todos los objetos necesarios en un solo paso
r.im <- imFromStack(r)
w <- winFromRaster(r)
puntos.2.ppp <- ppp(x = puntos.2$x,
y = puntos.2$y,
window = w,
check = F)
Q <- pixelquad(X = puntos.2.ppp, W = as.owin(w))
### Autocorrelación
K <- envelope(puntos.2.ppp, fun = Kest, nsim = 39)
plot(K)
plotQuantIntens(imList = r.im,
noCuts = 5,
Quad = Q,
p.pp = puntos.2.ppp,
dir = "",
name = "Respuestas-centroide")
### Medición de correlación entre covariables
pairs(r)
m1 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im)
m2 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im)
### Comparando los modelos
AIC(m1); AIC(m2)
### Analizar los efectos estimados
summary(m1)
par(mar = c(2,2,2,2))
diagnose.ppm(m1, main = "", cex.axis = 0.25)
### Diangnóstico - Residuales
par(mar = c(2,2,2,2))
diagnose.ppm(m2, main = "", cex.axis = 0.25)
### Diagnóstico - Ripley
K1 <- envelope(m1, fun = Kest, nsim = 39)
K2 <- envelope(m2, fun = Kest, nsim = 39)
plot(K1, cex = 0.5)
plot(K2, cex = 0.5)
### Revisando la predicción
plot(m1, se = F, main = "")
### Guardando los resultados
pred <- predict(m1)
pred.r <- raster(pred)
# Calculando centroide
coef(m1)
# Calculando centroide
c1 <- coef(m1)
-c1[2]/(2*c1[4])
centroide
-c1[3]/(2*c1[5])
r <- 0.5; mig = 0.15
set.seed(123)
n.pob <- 9
K <- rpois(n.pob, 5)
image(matrix(K, 3, 3))
image(matrix(K, 3, 3))
K
neigh <- matrix(c(0, 1, 0, 1, rep(0, 5),
1, 0, 1, 0, 1, rep(0, 4),
0, 1, 0, 0, 0, 1, rep(0, 3),
1, 0, 0, 0, 1, 0, 1, 0, 1,
0, 1, 0, 1, 0, 1, 0, 1, 0,
0, 0, 1, 0, 1, 0, 0, 0, 1,
0, 0, 0, 1, 0, 0, 0, 1, 0,
0, 0, 0, 0, 1, 0, 1, 0, 0,
0, 0, 0, 0, 0, 1, 0, 1, 0),
nrow = 9, ncol = 9)
image(neigh)
n.neigh <- rowSums(neigh)
N0 <- c(1, rep(0, n.pob-1))
N0
time = 25
N <- matrix(0, nrow = n.pob, ncol = time)
N[, 1] <- N0
N
for(i in 2:time){
E <- N[, i-1] * mig
I <- E %*% neigh / n.neigh
N[, i] <- N[, i-1 ] + r * N[, i-1] * (1- N[, i-1]/K) - E + I
}
library(animation)
saveGIF(
for(i in 1:time){image(matrix(N[, i], 3, 3), main = i)}
)
r <- rnorm(9, mean = 0.5, 0.2)
r
r <- rnorm(9, mean = 0.5, 0.5)
r
for(i in 2:time){
E <- N[, i-1] * mig
I <- E %*% neigh / n.neigh
N[, i] <- N[, i-1 ] + r * N[, i-1] * (1- N[, i-1]/K) - E + I
}
saveGIF(
for(i in 1:time){image(matrix(N[, i], 3, 3), main = i)}
)
knitr::opts_chunk$set(dev = 'pdf')
library(spatstat)
library(rgdal)
library(raster)
library(foreach)
archivos <- list.files("Datos-ejemplos/", "tif",
full.names = T,
recursive = F)
r <- stack(archivos)
plot(r)
class(r)
source("Funciones-spatstat/imFromStack.R")
r.im <- imFromStack(r)
class(r.im)
r.im[[1]]
plot(r.im)
plot(r.im[[1]])
plot(r.im[[1]])
source("Funciones-spatstat/winFromRaster.R")
w <- winFromRaster(r)
class(w)
set.seed(984573)
puntos <- data.frame(coordinates(r)[sample(1:840, 200),])
puntos$x <- puntos$x + rnorm(200, 0, 0.05)
puntos$y <- puntos$y + rnorm(200, 0, 0.05)
puntos
puntos.ppp <- ppp(x = puntos$x,
y = puntos$y,
window = w,
check = F)
class(puntos.ppp)
plot(puntos.ppp)
K <- envelope(puntos.ppp, fun = Kest, nsim = 39)
K <- envelope(puntos.ppp, fun = Kest, nsim = 49)
K <- envelope(puntos.ppp, fun = Kest, nsim = 39)
plot(K)
plot(K)
Q <- pixelquad(X = puntos.ppp, W = as.owin(w))
source("Funciones-spatstat/plotQuantIntens.R")
plotQuantIntens(imList = r.im,
noCuts = 5,
Quad = Q,
p.pp = puntos.ppp,
dir = "",
name = "Respuestas")
m1 <- ppm(Q = puntos.ppp,
trend = ~ Var.1,
covariates = r.im)
summary(m1)
m2 <- ppm(Q = puntos.ppp,
trend = ~ Var.2,
covariates = r.im)
m3 <- ppm(Q = puntos.ppp,
trend = ~ Var.3,
covariates = r.im)
AIC(m1); AIC(m2); AIC(m3)
m2 <- ppm(Q = puntos.ppp,
trend = ~ Var.2 + I(Var.2^2),
covariates = r.im)
m3 <- ppm(Q = puntos.ppp,
trend = ~ Var.3,
covariates = r.im)
AIC(m1); AIC(m2); AIC(m3)
m2 <- ppm(Q = puntos.ppp,
trend = ~ Var.2,
covariates = r.im)
m3 <- ppm(Q = puntos.ppp,
trend = ~ Var.3,
covariates = r.im)
AIC(m1); AIC(m2); AIC(m3)
m2 <- ppm(Q = puntos.ppp,
trend = ~ Var.2,
covariates = r.im)
m3 <- ppm(Q = puntos.ppp,
trend = ~ Var.3,
covariates = r.im)
AIC(m1); AIC(m2); AIC(m3)
plot(m2, trend = T, se = F)
knitr::opts_chunk$set(dev = 'pdf')
library(raster); library(rgdal); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos/", "tif",
full.names = T,
recursive = F)
r <- stack(archivos)
centroide <- cellStats(r, mean)
r.df <- data.frame(rasterToPoints(r))
covar <- cov(r.df[, 3:5])
md <- mahalanobis(r.df[, 3:5], center = centroide, cov = covar)
head(md)
md.r <- rasterFromXYZ(data.frame(r.df[, 1:2], md))
md.exp <- exp(-0.5*md.r)
plot(md.exp)
detach("package:raster", unload = TRUE)
detach("package:rgdal", unload = TRUE)
library(terra); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos/", "tif",
full.names = T,
recursive = F)
r <- stack(archivos)
library(terra); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos/", "tif",
full.names = T,
recursive = F)
r <- rast(archivos)
archivos <- list.files("Datos-ejemplos/", "tif",
full.names = T,
recursive = F)
archivos
r <- rast(archivos)
archivos <- list.files("Datos-ejemplos", "tif",
full.names = T,
recursive = F)
r <- rast(archivos)
r <- rast(archivos[[1]])
r <- rast(archivos[[2]])
knitr::opts_chunk$set(dev = 'pdf')
library(terra); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos", "tif",
full.names = T,
recursive = F)
r <- rast(archivos[[2]])
centroide <- global(r, mean)
r.df <- data.frame(rasterToPoints(r))
r.df <- as.data.frame(r, xy = T)
covar <- cov(r.df[, 3:5])
ncol(r)
ncol(r.df)
library(terra); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos", "tif",
full.names = T,
recursive = F)
r <- rast(archivos)
centroide <- global(r, mean)
r.df <- as.data.frame(r, xy = T)
covar <- cov(r.df[, 3:5])
md <- mahalanobis(r.df[, 3:5], center = centroide$mean, cov = covar)
head(md)
md
md.r <- rast(data.frame(r.df[, 1:2], md))
md.exp <- exp(-0.5*md.r)
plot(md.exp)
set.seed(182)
sam <- sample(1:nrow(r.df), 200, prob = exp(-0.5*md))
puntos.2 <- r.df[, 1:2][sam,]
set.seed(182)
sam <- sample(1:nrow(r.df), 200, prob = exp(-0.5*md))
puntos.2 <- data.frame(r.df[, 1:2][sam,])
puntos.2$x <- puntos.2$x + rnorm(200, 0, 0.05)
puntos.2$y <- puntos.2$y + rnorm(200, 0, 0.05)
plot(md.exp); points(puntos.2)
source("Funciones-spatstat/imFromStack.R")
source("Funciones-spatstat/winFromRaster.R")
source("Funciones-spatstat/plotQuantIntens.R")
r.im <- imFromStack(r)
w <- winFromRaster(r)
puntos.2.ppp <- ppp(x = puntos.2$x,
y = puntos.2$y,
window = w,
check = F)
Q <- pixelquad(X = puntos.2.ppp, W = as.owin(w))
K <- envelope(puntos.2.ppp, fun = Kest, nsim = 39)
plotQuantIntens(imList = r.im,
noCuts = 5,
Quad = Q,
p.pp = puntos.2.ppp,
dir = "",
name = "Respuestas-centroide")
curve(exp(1 + x - x^2), from = -3, 3)
pairs(r)
m1 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im)
names(r.im)
r.im <- imFromStack(r)
names(r.im) <- paste("Var", 1:3, sep = ".")
w <- as.owin(r.im[[1]])
puntos.2.ppp <- ppp(x = puntos.2$x,
y = puntos.2$y,
window = w,
check = F)
Q <- pixelquad(X = puntos.2.ppp, W = as.owin(w))
K <- envelope(puntos.2.ppp, fun = Kest, nsim = 39)
plot(K)
plotQuantIntens(imList = r.im,
noCuts = 5,
Quad = Q,
p.pp = puntos.2.ppp,
dir = "",
name = "Respuestas-centroide")
curve(exp(1 + x - x^2), from = -3, 3)
pairs(r)
m1 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im)
m2 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im)
AIC(m1); AIC(m2)
sum.m1 <- summary(m1)
knitr::kable(sum.m1$coefs.SE.CI[, 1:5])
par(mar = c(2,2,2,2))
diagnose.ppm(m1, main = "", cex.axis = 0.25)
par(mar = c(2,2,2,2))
diagnose.ppm(m2, main = "", cex.axis = 0.25)
K1 <- envelope(m1, fun = Kest, nsim = 39)
K2 <- envelope(m2, fun = Kest, nsim = 39)
plot(K1, cex = 0.5)
plot(K2, cex = 0.5)
plot(m1, se = F, main = "")
pred <- predict(m1)
pred.r <- rast(pred)
writeRaster(pred.r, "Predicción-m1", "GTiff",
overwrite = T)
pred <- predict(m1)
pred.r <- rast(pred)
writeRaster(pred.r, "Predicción-m1.tif",
overwrite = T)
rr <- data.frame(r=seq(1,5,by=1))
p <- profilepl(rr, Strauss,
puntos.2.ppp ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im, aic=T, rbord = 0.5)
plot(p, main = "")
m1.int <- ppm(Q = puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
Strauss(p$iopt), rbord = 1) #Interacción
sum.int <- summary(m1.int)
knitr::kable(sum.int$coefs.SE.CI[, 1:4])
library(terra); library(foreach); library(spatstat)
archivos <- list.files("Datos-ejemplos", "tif",
full.names = T,
recursive = F)
r <- rast(archivos)
r <- scale(r)
centroide <- global(r, mean)
r.df <- as.data.frame(r, xy = T)
covar <- cov(r.df[, 3:5])
md <- mahalanobis(r.df[, 3:5], center = centroide$mean, cov = covar)
head(md)
md.r <- rast(data.frame(r.df[, 1:2], md))
md.exp <- exp(-0.5*md.r)
plot(md.exp)
set.seed(182)
sam <- sample(1:nrow(r.df), 200, prob = exp(-0.5*md))
puntos.2 <- data.frame(r.df[, 1:2][sam,])
puntos.2$x <- puntos.2$x + rnorm(200, 0, 0.05)
puntos.2$y <- puntos.2$y + rnorm(200, 0, 0.05)
plot(md.exp); points(puntos.2)
source("Funciones-spatstat/imFromStack.R")
source("Funciones-spatstat/winFromRaster.R")
source("Funciones-spatstat/plotQuantIntens.R")
r.im <- imFromStack(r)
names(r.im) <- paste("Var", 1:3, sep = ".")
w <- as.owin(r.im[[1]])
puntos.2.ppp <- ppp(x = puntos.2$x,
y = puntos.2$y,
window = w,
check = F)
Q <- pixelquad(X = puntos.2.ppp, W = as.owin(w))
plotQuantIntens(imList = r.im,
noCuts = 5,
Quad = Q,
p.pp = puntos.2.ppp,
dir = "",
name = "Respuestas-centroide")
curve(exp(1 + x - x^2), from = -3, 3)
pairs(r)
m1 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im)
m2 <- ppm(Q = puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im)
AIC(m1); AIC(m2)
sum.m1 <- summary(m1)
knitr::kable(sum.m1$coefs.SE.CI[, 1:5])
par(mar = c(2,2,2,2))
diagnose.ppm(m1, main = "", cex.axis = 0.25)
plot(m1, se = F, main = "")
pred <- predict(m1)
pred.r <- rast(pred)
writeRaster(pred.r, "Predicción-m1.tif",
overwrite = T)
rr <- data.frame(r=seq(1,5,by=1))
p <- profilepl(rr, Strauss,
puntos.2.ppp ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im, aic=T, rbord = 0.5)
rr <- data.frame(r=seq(1,5,by=1))
p <- profilepl(rr, Strauss,
puntos.2.ppp ~ Var.1 + Var.3 + I(Var.1^2) + I(Var.3^2),
covariates = r.im, aic=F, rbord = 0.1)
plot(p, main = "")
p$iopt
m1.int <- ppm(Q = puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
AreaInter(rr$r[p$iopt]), rbord = 0.1) #Interacción
sum.int <- summary(m1.int)
knitr::kable(sum.int$coefs.SE.CI[, 1:4])
coef(m1)
coef(m1.int)
K.int <- envelope(m1.int, Kest, nsim = 39)
plot(K.int)
plot(m1.int, se = F, trend = T, cif = F)
plot(m1.int, se = F, trend = T, cif = T)
plot(m1.int, se = F, trend = T, cif = F)
plot(m1.int, se = F, trend = T, cif = T)
plot(m1)
plot(m1.int, se = F, trend = T, cif = F)
plot(m1, se = F, trend = T)
par(mfrow = c(1, 2))
plot(m1, se = F, trend = T, main = "Poisson")
plot(m1.int, se = F, trend = T, cif = F, main = "Interacción")
m1.lgcp <- kppm(puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
clusters = "LGCP",
statistic = "K", # K de Ripley
method = "clik2", # Contraste con K
model = "exp") # Modelo de varianza
m1.lgcp <- kppm(puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
clusters = "Thomas",
statistic = "K", # K de Ripley
method = "mincon", # Contraste con K
model = "exp")
sum.lgcp <- summary(m1.lgcp)
knitr::kable(sum.lgcp$coefs.SE.CI[, 1:4])
plot(m1.lgcp, what = "intensity")
K.lgcp <- envelope(m1.lgcp, Kest, nsim = 39)
plot(K.lgcp)
par(mfrow = c(1, 3))
plot(m1, se = F, trend = T, main = "Poisson")
plot(m1.int, se = F, trend = T, cif = F, main = "Interacción")
plot(m1.lgcp, what = "intensity", main = "LGCP")
plot(m1.lgcp, what = "cluster", main = "LGCP")
plot(m1.lgcp, what = "statistic", main = "LGCP")
m1.lgcp <- kppm(puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
clusters = "LGCP",
statistic = "K", # K de Ripley
method = "mincon", # Contraste con K
model = "exp")
m1.lgcp <- kppm(puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
clusters = "Thomas",
statistic = "K", # K de Ripley
method = "mincon", # Contraste con K
model = "exp")
m1.lgcp <- kppm(puntos.2.ppp,
trend = ~ Var.2 + Var.3 + I(Var.2^2) + I(Var.3^2),
covariates = r.im,
clusters = "LGCP",
statistic = "K", # K de Ripley
method = "mincon")
sum.lgcp <- summary(m1.lgcp)
sum.lgcp
par(mfrow = c(1, 3))
plot(m1, se = F, trend = T, main = "Poisson")
plot(m1.int, se = F, trend = T, cif = F, main = "Interacción")
plot(m1.lgcp, what = "intensity", main = "LGCP")
m1
m2
par(mfrow = c(1, 3))
plot(m2, se = F, trend = T, main = "Poisson")
plot(m1.int, se = F, trend = T, cif = F, main = "Interacción")
plot(m1.lgcp, what = "intensity", main = "LGCP")
K.lgcp <- envelope(m1.lgcp, Kest, nsim = 39)
plot(K.lgcp)
